# find_replace_intTXT
Скрипт для поиска и замены текста в json
Собирается прокт путем компиляции main.cpp файла в .exe, далее программа работает самостоятельно, ничего кроме коспиляции делать не нужно.

Инструкция по работе: 
После запуска пользователю даётся выбор между двумя режимами запуска: 
1.	Команда --start запускает программу в режиме без генерации .json файлов для работы с уже имеющимися файлами. 
2.	Команда --start-generate запускает программу в режиме с генерацией .json файлов, описание алгоритма которого будет далее. 
 
В случае, если была введена команда --start-generate, при запуске генерируется рандомное количество .json файлов в количестве от 5 до 10 шт., далее эти .json файлы заполняются рандомным количеством строк в формате {name : “” , content : “”} в установленном диапазоне (400к500к) в равной степени каждый, то есть этим диапазоном устанавливается общее количество строк, которое в равной степени разделяется между всеми сгенерированными .json файлами, кроме последнего, в который уходит помимо основного количества еще и неделимый остаток, то есть пример: Указывается диапазон 60-100 строк, после генерируется из рандомного числа условно 5 .json файлов.  
Далее генератор выбирает из диапазона 60-100 сгенерировать 76 строк. 76 делится на 5 файлов, значит в каждом будет по 15 файлов, кроме последнего, в котором будет 16 строк.  
Далее эти объекты вида {name : “” , content : “”} заполняются типизированным именем file_номер файла.расширение и контентом, который зависит от расширения файла: если это .csv файл, то он заполняется случайным количеством столбцов в заданном диапазоне, и в каждом столбце заполняется случайным количеством случайных латинских строчных букв, количество столбцов и букв в содержании генерируется рандомно в заданном диапазоне, что позволяет генерировать практически уникальное содержание в каждом файлесодержании, а если это .txt файл, то генерируется случайное количество случайных строчных латинских букв в заданном диапазоне, так же для уникализации содержания.  
Далее пользователю сообщается об успешной генерации .json файлов и предлагается ввести команду для дальнейшей работы, если пользователь не знает команд, то ему также предлагается ввести команду --help, которая выводит список доступных для ввода команд, а именно:   
  
•	Получение информации о доступных командах - "--help"  
•	Поиск слова в содержании файлов - "--find"  
•	Замена содержимого во всех файлах - "--replaceall"   
•	Замена содержимого только в одном файле - "--replacein"  
•	Режим "ТОЛЬКО ПОИСК" - "--dry-run"   
•	Завершение работы и удаление json файлов - "--exit"  
•	Завершение работы без удаления json файлов – “--exitn” 
 
В случае ввода команды --start пользователю сразу предлагается ввести команду для дальнейшей работы, пропуская этап с генерацией. 
В случае ввода команды --find пользователю выдается сообщение с просьбой ввода искомой подстроки, после которого происходит поиск заданной подстроки по всем строкам всех .json файлов. Далее выводится результат поиска в следующем виде:  
  
| название .json файла | название файласодержания | содержание строки |  
  
и в конце выводится общее количество найденных совпадений.  
  
В случае ввода команды --replaceall, которая отвечает за замену всех подходящих подстрок в выбранном .json файле, пользователю выводится сообщение с просьбой ввести данные в следующем виде:  
  
название .json файла без расширения -> что заменить -> на что заменить  
  
после чего происходит замена заданной подстроки на новую, с выводом 
пользователю сообщения о количестве совершенных замен, а в случае безуспешной замены, то есть отсутствия заданной подстроки в файлахсодержании, выводится сообщение о нулевом количестве замен. В случае ввода неверного названия .json файла выводится сообщение о том, что данный файл не был найден.   
  
В случае ввода команды --replacein, которая отвечает за замену всех подходящих подстрок в выбранном .json файле и выбранном пользователем файлесодержании, пользователю выводится сообщение с просьбой ввести данные в следующем виде:  
  
название .json файла без расширения -> название файла содержании ->  что заменить -> на что заменить  
  
после чего происходит замена заданной подстроки на новую, с выводом 
пользователю сообщения о количестве совершенных замен в содержании заданного файласодержания, а в случае безуспешной замены, то есть отсутствия заданной подстроки в заданном файлесодержании, или отсутствия заданного файласодержания в указанном .json файле, выводится сообщение о нулевом количестве замен. В случае ввода неверного названия .json файла выводится сообщение о том, что данный файл не был найден.  
 
В случае ввода команды --exit будет совершено удаление всех сгенерированных .json файлов с последующим завершением работы программы и выводом пользователю сообщения об этом.  
 
В случае ввода команды --exitn будет произведено завершение работы программы без удаления .json файлов с выводом пользователю сообщения об этом. 
  
В случае ввода команды --dry-run будет включен режим  
 “ТОЛЬКО ПОИСК”, который подразумевает использование только режима поиск, то есть команду --find, в данном режиме не доступны режимы замены, соответственно недоступны команды --replacein и --replaceall, но остаются доступными команды --help && --exit && --exitn, а также появляется команда --dry-end, которая завершает режим “ТОЛЬКО ПОИСК”, и переводит работу программы в обычный режим.  
  
В случае ввода неизвестной команды выведется сообщение об ошибке, что команда неизвестна, для получения списка доступных команд будет предложено ввести команду --help.  
  
Также, после завершения работы программы, формируется отчет, в котором находятся следующие данные:  
  
•	Дата и время отчёта.  
•	Продолжительность сессии.  
•	Общее количество введённых команд.  
•	Общее количество найденных совпадений.  
•	Общее количество выполненных замен.  
•	Количество замен по файлам со списком файлов с заменами.  
